B/Utils version 0.02
====================

NAME
    B::Utils - Helper functions for op tree manipulation

What's new in this version:
    * Fixed some brown-bag bugs
    * Added the following Fun Things:

    walkoptree_simple($op, \&callback, [$data])
       The "B" module provides various functions to walk the op tree, but
       they're all rather difficult to use, requiring you to inject methods
       into the "B::OP" class. This is a very simple op tree walker with
       more expected semantics.

       All the "walk" functions set "B::Utils::file" and "B::Utils::line" to
       the appropriate values of file and line number in the program being
       examined.

    walkoptree_filtered($op, \&filter, \&callback, [$data])
       This is much the same as "walkoptree_simple", but will only call the
       callback if the "filter" returns true. The "filter" is passed the op
       in question as a parameter; the "opgrep" function is fantastic for
       building your own filters.

    walkallops_simple(\&callback, [$data])
       This combines "walkoptree_simple" with "all_roots" and "anon_subs" to
       examine every op in the program. "$B::Utils::sub" is set to the
       subroutine name if you're in a subroutine, "__MAIN__" if you're in
       the main program and "__ANON__" if you're in an anonymous subroutine.

    walkallops_filtered(\&filter, \&callback, [$data])
       Same as above, but filtered.

    carp(@args)
    croak(@args)
       Warn and die, respectively, from the perspective of the position of
       the op in the program. Sounds complicated, but it's exactly the kind
       of error reporting you expect when you're grovelling through an op
       tree.

    opgrep(\%conditions, @ops)
       Returns the ops which meet the given conditions. The conditions
       should be specified like this:

           @barewords = opgrep(
                               { name => "const", private => OPpCONST_BARE },
                               @ops
                              );

       You can specify alternation by giving an arrayref of values:

           @svs = opgrep ( { name => ["padsv", "gvsv"] }, @ops)

       And you can specify inversion by making the first element of the
       arrayref a "!". (Hint: if you want to say "anything", say "not
       nothing": "["!"]")

       You may also specify the conditions to be matched in nearby ops.

           walkallops_filtered(
               sub { opgrep( {name => "exec", 
                              next => {
                                        name    => "nextstate",
                                        sibling => { name => [qw(! exit warn die)] }
                                      }
                             }, @_)},
               sub { 
                     carp("Statement unlikely to be reached"); 
                     carp("\t(Maybe you meant system() when you said exec()?)\n");
               }
           )

       Get that?

       Here are the things that can be tested:

               name targ type seq flags private pmflags pmpermflags
               first other last sibling next pmreplroot pmreplstart pmnext

INSTALLATION

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install

DEPENDENCIES

This module does *not* require anything that's not in core.

COPYRIGHT AND LICENCE

AL & GPL. You know the score.

Copyright (C) 2001 Simon Cozens

